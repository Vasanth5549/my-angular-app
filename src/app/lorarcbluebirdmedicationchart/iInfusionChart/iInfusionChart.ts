import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, Output, QueryList, TemplateRef, ViewChild, ViewChildren } from '@angular/core';
import { GridComponent, RowClassArgs } from "@progress/kendo-angular-grid";
import DateTime from 'epma-platform/DateTime';
import TimeSpan from 'epma-platform/TimeSpan';
import { Border, Color, Colors, DataTemplate, FrameworkElement, Grid, GridLength, Image, MouseButtonEventArgs, SolidColorBrush, Thickness, UserControl, iButton, iLabel } from 'epma-platform/controls';
import { Dictionary } from 'epma-platform/dictionary';
import { ObjectHelper } from 'epma-platform/helper';
import { List, ObservableCollection, Visibility } from 'epma-platform/models';
import { AppLoadService, BusyIndicator, iBusyIndicator } from 'epma-platform/services';
import 'epma-platform/stringextension';
import { Subject } from 'rxjs';
import { RoutedEventArgs, SizeChangedEventArgs } from 'src/app/shared/epma-platform/controls/FrameworkElement';
import { GridExtension, GridViewLength, GridViewLengthUnitType, GridViewRow, RowLoadedEventArgs, TextAlignment, iGridViewDataColumn, iGridViewHeaderRow } from 'src/app/shared/epma-platform/controls/epma-grid-helpers/grid-extension';
import { ChartIcon } from '../common/ChartIcon';
import { DrugItem } from '../common/DrugItem';
import { InfusionChartCell } from '../common/InfusionChartCell';
import { InfusionChartColumn } from '../common/InfusionChartColumn';
import { InfusionChartRow } from '../common/InfusionChartRow';
import { InfusionTagObject } from '../common/InfusionTagObject';
//import { InfusionCellComponent } from '../iInfusionChart/infusion-cell/infusion-cell.component';
import { ActionByWrapConverterPipe, CommentsWrapConverterPipe, ImageURIBitMapPipe, InfusionDoseWrapConverterPipe, InfusionRouteWrapConverterPipe, LineBreakWrapConverterPipe, OmitWrapConverterPipe, PrescribedByWrapConverterPipe, ReasonWrapConverterPipe, ReviewWrapConverterPipe, StartDTWrapConverterPipe, StopDTWrapConverterPipe } from 'src/app/lorarcbluebirdmedicationchart/converter/MedChartConverter.pipe';
import { IEnableDST } from 'src/app/shared/epma-platform/models/EnableDST';
import { DrugHeader } from 'src/app/shared/epma-platform/soap-client/MedicationAdministrationWS';
import * as ControlStyles from '../../shared/epma-platform/controls/ControlStyles';
import { InfusionCell } from './infusion-cell/infusion-cell.component';
@Component({
    selector: 'iInfusionChart',
    templateUrl: './iInfusionChart.html',
    styleUrls: ['./iInfusionChart.css'],
    changeDetection: ChangeDetectionStrategy.OnPush
})

export class iInfusionChart extends UserControl implements IEnableDST {

    public Styles = ControlStyles;
    private oChartColumns: List<InfusionChartColumn>;
    private RowCount: number = 0;
    private IsCurrentTime: boolean = false;
    public static oInfusionChart: iInfusionChart;
    private IsAutoGenerated: boolean = false;
    private _HeaderBorder: Border = new Border();
    private bNextDisable: boolean;
    private bPreviousDisable: boolean;
    ImageURIBitMap: ImageURIBitMapPipe = new ImageURIBitMapPipe();
    InfusionDoseWrap: InfusionDoseWrapConverterPipe = new InfusionDoseWrapConverterPipe();
    StartDTWrap: StartDTWrapConverterPipe = new StartDTWrapConverterPipe();
    StopDTWrap: StopDTWrapConverterPipe = new StopDTWrapConverterPipe();
    ReviewWrap: ReviewWrapConverterPipe = new ReviewWrapConverterPipe();
    CommentsWrap: CommentsWrapConverterPipe = new CommentsWrapConverterPipe();
    ReasonWrap: ReasonWrapConverterPipe = new ReasonWrapConverterPipe();
    ActionWrap: ActionByWrapConverterPipe = new ActionByWrapConverterPipe();
    PrescribedByWrap: PrescribedByWrapConverterPipe = new PrescribedByWrapConverterPipe();
    InfusionRouteWrap: InfusionRouteWrapConverterPipe = new InfusionRouteWrapConverterPipe();
    OmitWrap: OmitWrapConverterPipe = new OmitWrapConverterPipe();
    LineBreakWrap: LineBreakWrapConverterPipe = new LineBreakWrapConverterPipe();
    @Output() ChartColumnEmit: EventEmitter<any> = new EventEmitter<any>;

    @ViewChild('cellitemtemRef') cellitem: TemplateRef<any>;
    @ViewChild('drugDetails') drugDetail: TemplateRef<any>;
    // #region viewchild
    private grdHeader: Grid = new Grid();
    LayoutRoot: any;
    isLoaded: boolean = false;
    statusComplRow: any[] = [];
    heightDictionary: Dictionary<any, any> = new Dictionary<any, any>();
    chartdetailsCellList: Dictionary<string, any> = new Dictionary<string, any>();
    selRowIndx: number = 0;
    rowrefresh: boolean = false;
    refreshRowBehaviorSubject : Subject<boolean> = new Subject();
    initialLoad: boolean = false;

    @ViewChild("grdHeaderTempRef", { read: Grid, static: false }) set _grdHeader(c: Grid) {
        if (c) { this.grdHeader = c; }
    };
    public txbDrugHeader: iLabel = new iLabel();
    @ViewChild("txbDrugHeaderTempRef", { read: iLabel, static: false }) set _txbDrugHeader(c: iLabel) {
        if (c) { this.txbDrugHeader = c; }
    };
    private PreviousDayView: iButton = new iButton();
    @ViewChild("PreviousDayViewTempRef", { read: iButton, static: false }) set _PreviousDayView(c: iButton) {
        if (c) { this.PreviousDayView = c; }
    };
    public txbTimeHeader: iLabel = new iLabel();
    @ViewChild("txbTimeHeaderTempRef", { read: iLabel, static: false }) set _txbTimeHeader(c: iLabel) {
        if (c) { this.txbTimeHeader = c; }
    };
    private NextDayView: iButton = new iButton();
    @ViewChild("NextDayViewTempRef", { read: iButton, static: false }) set _NextDayView(c: iButton) {
        if (c) { this.NextDayView = c; }
    };

    public InfusionControl: GridExtension = new GridExtension();
    // @ViewChildren(DataTemplate) dataTemplates: QueryList<DataTemplate>;
    // for igrid dynamic column
    public dataTemplates: QueryList<DataTemplate>;
    @ViewChildren(DataTemplate) set _dataTemplates(c: QueryList<DataTemplate>) {
        if (c) {
            this.dataTemplates = c;
            this.InfusionControl.dataTemplates = c;
        }
    }

    @Input() get isChildWizard(){
        return AppLoadService.isChildWizard;
    }
    
    private renderRows(c) {
        if (this.ChartRows && this.ChartRows.Count > 0) {
            for (let i:number = 0; i < this.ChartRows.Count ; i++) {
                 this.assignContent(i);
            }
            setTimeout(() => {
                if(this.changeDetectionRef)
                    this.changeDetectionRef.markForCheck();
            }, 0);
        }
    }
    private assignContent(i, chartRow?: InfusionChartRow) {
        let context: { index: any, dataItem: any } = { index: 0, dataItem: {} };
        context.index = i;
        this.rowrefresh = false;
        context.dataItem = this.ChartRows[i];
        let rowEventArgs = this.InfusionControl.GetRowEventArgs(this.dataTemplates, context, false, true);
        rowEventArgs.Row.DataContext = this.ChartRows[i];
        this.InfusionControl_RowLoaded(rowEventArgs);
            if (rowEventArgs.index == this.InfusionControl.ItemsSource?.Count - 1) {
             //   console.log('tabitem.length',iBusyIndicator.arrDialogRef.length);
                let length = iBusyIndicator.arrDialogRef.length;
                if(length > 0){
                    for(i=0; i < length; i++){
                     //   console.log('tabitem.loop.length',length);
                      BusyIndicator.SetStatusIdle("InfusionChart");
                    }
                }
                BusyIndicator.SetStatusIdle("InfusionChart");
            }
       
       
    }
    temploadData(heightinput) {
        let idx = 6;//heightinput.value;
        if(heightinput){
            idx = heightinput.value;
        }
        let context: { index: any, dataItem: any } = { index: 0, dataItem: {} };
        context.index = idx;
        context.dataItem = this.ChartRows[idx];
        let rowEventArgs = this.InfusionControl.GetRowEventArgs(this.dataTemplates, context, false, true);
        if(heightinput){
        console.log('reload.temploadData.desiredHeight',this.ChartRows[idx].Key,rowEventArgs.Row.Cells[0]?.DesiredSize?.Height,rowEventArgs.Row.Cells[0]?.DesiredSize?.['Height']);
        }else{
            console.log('reload.temploadData.interval',this.ChartRows[idx].Key,rowEventArgs.Row.Cells[0]?.DesiredSize?.Height,rowEventArgs.Row.Cells[0]?.DesiredSize?.['Height']);

        }
      }
    public afterViewInitColumnLoaded = false;
    @ViewChild('InfusionControlTempRef', { read: GridComponent })
    set _kendoGrid(c: GridComponent) {
        if (c) {
            this.InfusionControl.grid = c;
            this.InfusionControl.columns = c.columns;
            if (this.afterViewInitColumnLoaded)
                this.InfusionControl.GenerateColumns();

        }
    }
    // #endregion viewchild
    private _chartrows: any;
    ngAfterViewInit(): void {
        this.InfusionControl.GenerateColumns();
        this.afterViewInitColumnLoaded = true;
        this.iInfusionChart_Loaded(null, null);
       
        this.initialLoad = true;
      
        this.dataTemplates.changes.subscribe((children)=>{
         this.chartdetailsCellList = new Dictionary<string, any>();
            this.heightDictionary = new Dictionary<any,any>();
            setTimeout(() => {           
             this.renderRows(children);
            }, 0);
           
        });
    //   this.InfusionControl.RefreshDataTemplateHeight(this.dataTemplates);
    }

    ngOnInit(): void {
     this.InfusionControl.IsFullCellHeightDataTemplate = true;
         this.InfusionControl.onCellClick = (s, e) => {
            if (this.chartdetailsCellList && this.chartdetailsCellList.Count() > 0) {
                let key = e.RowIndex+"-"+e.ColumnIndex;
                let rowdetails = this.chartdetailsCellList.ContainsKey(key);
                if (rowdetails) {
                    let sender = this.chartdetailsCellList[key];
                    if (sender)
                        this.Chart_MouseLeftButtonDown(sender, e);
                }
            }
        };
    }
    constructor(private changeDetectionRef?: ChangeDetectorRef) {
        super();
        iInfusionChart.oInfusionChart = this;
        // commenting iThemeManager since it is not defined in the project iThemeManager.SetApplicationTheme("/LorArcBlueBirdTheme;component/Themes/Generic.xaml");
        //   public static class iThemeManager is missing, namespace iSOFT.LORENZO.BlueBird.Theme 
    }

    @Input() OnDrugHotSpotClick: Function;
    @Input() OnChartHotSpotClick: Function;
    @Input() OnPreviousClick: Function;
    @Input() OnNextClick: Function;
    public OnErrorLog: Function;
    @Input() OnPreviousClickComplete: Function;
    @Input() OnNextClickComplete: Function;
    public EnableDST: boolean;
    public AutoGenerateColumn: boolean;
    private _StartDate: DateTime;
    private _EndDate: DateTime;
    private _ChartInterval: TimeSpan;
    public CurrentDateTime: DateTime = new DateTime();
    private _DrugHeader: DrugHeader;

    public get DrugHeader(): DrugHeader {
        return this._DrugHeader;
    }
    @Input() set DrugHeader(value: any) {
        this._DrugHeader = value;
    }
    public get ChartInterval(): TimeSpan {
        return this._ChartInterval;
    }
    @Input() set ChartInterval(value: any) {
        this._ChartInterval = value;
    }
    public get StartDate(): DateTime {
        return this._StartDate;
    }
    @Input() set StartDate(value: any) {
        this._StartDate = value;
    }
    public get EndDate(): DateTime {
        return this._EndDate;
    }
    @Input() set EndDate(value: any) {
        this._EndDate = value;
    }
    public get EnableNextButton(): boolean {
        return this.bNextDisable;
    }
    @Input() set EnableNextButton(value: boolean) {
        this.bNextDisable = value;
    }
    public get EnablePreviousButton(): boolean {
        return this.bPreviousDisable;
    }
    @Input() set EnablePreviousButton(value: boolean) {
        this.bPreviousDisable = value;
    }
    private _DrugHeaderText: string;
    public get DrugHeaderText(): string {
        return this._DrugHeaderText;
    }
    @Input() set DrugHeaderText(value: string) {
        this._DrugHeaderText = value;
    }
    private _Timeheader: string;
    public get Timeheader(): string {
        return this._Timeheader;
    }
    @Input() set Timeheader(value: string) {
        this._Timeheader = value;
    }
    // private oChartRows: ObservableCollection<InfusionChartRow>;
    // public get ChartRows() {
    //     return this.oChartRows;
    // }
    // @Input() set ChartRows(chartData: any) {
    //     this.objDictrowCnt.Clear();
    //     if(chartData){
    //         this.InfusionControl.ItemsSource = chartData;
    //     }
    //     this.oChartRows = chartData;
    //   //  console.log("InfusionControl.ItemsSource",chartData);
    // }

    iInfusionChart_Loaded(sender: Object, e: RoutedEventArgs): void {
        this.AutoGenerateColumn = true;
        try {
            if (this.AutoGenerateColumn && this.IsValidDate(this.StartDate) && this.IsValidDate(this.EndDate)) {
                this.ChartColumns = null;
                this.GenerateColumnList();
            }
            // revisit this.InfusionControl.FrozenColumnCount = 1;  // added 'FrozenColumnCount' property in GridExtension.ts
            this.txbDrugHeader.Text = this.DrugHeaderText;
            this.txbTimeHeader.Text = this.Timeheader;
            this.PreviousDayView.IsEnabled = this.EnablePreviousButton;
            this.NextDayView.IsEnabled = this.EnableNextButton;
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }
    }
    private GenerateColumnList(): void {
        try {
            this.objDictrowCnt.Clear();
            let colInd: number = 0;
            let objChartCols: List<InfusionChartColumn> = new List<InfusionChartColumn>();
            let oDrugCol: InfusionChartColumn = ObjectHelper.CreateObject(new InfusionChartColumn(), { Caption: String.Empty, Index: colInd, IsCurrentTime: false });
            objChartCols.Add(oDrugCol);
            colInd += 1;
            //  let TotalInterval: any = <number>Math.Round((this.EndDate - this.StartDate).TotalHours) / this.ChartInterval.Hours; not used anywhere 
            for (let sD: DateTime = this.StartDate; sD < this.EndDate; sD = sD.AddHours(this.ChartInterval.Hours)) {
                let oChartcol: InfusionChartColumn = new InfusionChartColumn();
                oChartcol.StartRange = sD.Hour;
                oChartcol.StartDateTime = sD;
                oChartcol.EndRange = sD.AddHours(this.ChartInterval.Hours).Hour;
                oChartcol.EndDateTime = sD.AddMinutes(-1).AddHours(this.ChartInterval.Hours);
                oChartcol.Caption = oChartcol.StartRange.ToString() + "-" + sD.AddHours(this.ChartInterval.Hours).Hour.ToString();
                oChartcol.Index = colInd;
                oChartcol.CurrentDateTime = this.CurrentDateTime;
                oChartcol.CInterval = (this.ChartInterval.Hours * 60);
                if (sD <= this.CurrentDateTime && this.CurrentDateTime <= sD.AddMinutes(-1).AddHours(this.ChartInterval.Hours))
                    oChartcol.IsCurrentTime = true;
                else oChartcol.IsCurrentTime = false;
                // change to 70px
                oChartcol.Width = 70;
                objChartCols.Add(oChartcol);
                colInd += 1;
            }

            this.ChartColumns = objChartCols;

            this.IsAutoGenerated = true;
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }

    }
    public get ChartColumns(): List<InfusionChartColumn> {
        return this.oChartColumns;
    }
    public set ChartColumns(value: List<InfusionChartColumn>) {
        try {
            if (!this.IsAutoGenerated) {
                this.InfusionControl.CanUserSelect = true;
                // Bug 36798: 'SelectionMode' only refers to a type, but is being used as a value here. need to check
                //this.InfusionControl.SelectionMode = SelectionMode.Multiple; 
                this.oChartColumns = value;
                if (this.oChartColumns != null) {
                    this.InfusionControl.Width = this.Width;
                    this.InfusionControl.Height = this.Height;
                    let nColIndex: number = 0;
                    this.oChartColumns.forEach((oColumn) => {
                        let oDataColumn: iGridViewDataColumn = new iGridViewDataColumn();
                        oDataColumn.Header = oColumn.Caption;
                        oDataColumn.IsReorderable = false; // added 'IsReorderable' missing property in GridViewColumn
                        oDataColumn.IsReadOnly = true;
                        if (oColumn.Index == nColIndex) {
                            oDataColumn.Width = new GridViewLength(1, GridViewLengthUnitType.Star);
                            //  oDataColumn.ActualWidth = new GridViewLength(1, GridViewLengthUnitType.Star);
                            if (this.IsAutoGenerated) {
                                if (this.InfusionControl.Width as number <= (this.ChartColumns.Sum(s => s.Width) + 20)) {
                                    oDataColumn.MinWidth = 900;
                                }
                                else {
                                    oDataColumn.MinWidth = this.InfusionControl.Width?.Value - (this.ChartColumns.Sum(s => s.Width) + 32);
                                }
                            }
                            // oDataColumn.Width = 809;//1010;
                            // oDataColumn.MinWidth = 809;//1010;
                        }
                        else {
                            oDataColumn.MinWidth = oColumn.Width;
                            oDataColumn.Width = oColumn.Width;
                        }
                        // Please refer the guideline document for the below code implementation
                        //  oDataColumn.HeaderCellStyle = "HeaderCellStyle";
                        //oDataColumn.CellStyle = ObjectHelper.CreateType<Style>(App.Current.Resources["CellStyle"], Style);  // added 'CellStyle' missing property in GridViewColumn--> Hari's team will work on it
                        oDataColumn.HeaderTextAlignment = TextAlignment.Center; //added 'HeaderTextAlignment' missing property in GridViewColumn--> Hari's team will work on it
                        oDataColumn.IsHeaderWordWrap = true;
                        this.InfusionControl.dColumns.Add(oDataColumn); // old code:  this.InfusionControl.Columns.Add(oDataColumn);
                    });
                }
                if (this.ChartColumns != null) {
                    this.InfusionControl.ItemsSource = this.ChartRows;
                    if (this.ChartRows == null || this.ChartRows.Count == 0)
                        this.InfusionControl.ShowColumnHeaders = false;
                    else this.InfusionControl.ShowColumnHeaders = true;
                }
                if (this.InfusionControl.Columns.Count > 0) {
                    // this.grdHeader.ColumnDefinitions[0].Width = new GridLength(this.InfusionControl.Columns[0].ActualWidth + 2);
                }
            }
            else {
                this.oChartColumns = value;
                if (this.oChartColumns != null) {
                    let nColIndex: number = 0;
                    this.oChartColumns.forEach((oColumn) => {
                        if (oColumn.Index != nColIndex) {
                            this.InfusionControl.dColumns[oColumn.Index].Header = oColumn.Caption;
                        }
                    });
                }
            }
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }

    }
    // click event for all drugitem images
    Drug_MouseEvent = (s, e) => { this.Drug_MouseLeftButtonDown(s, e); };

    rowCallback = (context: RowClassArgs) => {
        let rowStyles = this.InfusionControl.getRowClasses(context);
        return rowStyles;
    };
    //revisit
    static ChartRowsProperty = "oChartRows";

    public get ChartRows(): ObservableCollection<InfusionChartRow> {
        // return ObjectHelper.GetValue(iInfusionChart, iInfusionChart.ChartRowsProperty); 
        return this._chartrows;
    }
    public set ChartRows(value: ObservableCollection<InfusionChartRow>) {
        this.statusComplRow = [];
        this.objDictrowCnt.Clear();
        // ObjectHelper.SetValue(iInfusionChart, iInfusionChart.ChartRowsProperty, value);
        this._chartrows = value;
        this.InfusionControl.SetBinding('data',this.ChartRows);
        // set the MouseLeftButtonDown in chartIcon
        this.InfusionControl.ItemsSource?.array.forEach((element: InfusionChartRow) => {
            if (element.DrugItem) {
                if (element.DrugItem.MultiComponentIcon) {
                    element.DrugItem.MultiComponentIcon.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.CriticalIcon) {
                    element.DrugItem.CriticalIcon.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.DrugPropertyIcon) {
                    element.DrugItem.DrugPropertyIcon.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                if (element.DrugItem.MultiComponentIcon1) {
                    element.DrugItem.MultiComponentIcon1.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.FluidDrugPropertyIcon) {
                    element.DrugItem.FluidDrugPropertyIcon.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.DrugPropertyIcon) {
                    element.DrugItem.DrugPropertyIcon.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                if (element.DrugItem.ComponenetPropertyIcon1) {
                    element.DrugItem.ComponenetPropertyIcon1.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.ComponenetPropertyIcon2) {
                    element.DrugItem.ComponenetPropertyIcon2.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.MultiComponentIcon2) {
                    element.DrugItem.MultiComponentIcon2.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                if (element.DrugItem.ComponenetPropertyIcon3) {
                    element.DrugItem.ComponenetPropertyIcon3.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.MultiComponentIcon3) {
                    element.DrugItem.MultiComponentIcon3.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.ComponenetPropertyIcon4) {
                    element.DrugItem.ComponenetPropertyIcon4.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
                else if (element.DrugItem.MultiComponentIcon4) {
                    element.DrugItem.MultiComponentIcon4.MouseLeftButtonDown = this.Drug_MouseEvent;
                }
            }
        });
        if (value == null || this.ChartRows?.Count == 0)
            this.InfusionControl.ShowColumnHeaders = false;
        else this.InfusionControl.ShowColumnHeaders = true;
        if(this.changeDetectionRef)
            this.changeDetectionRef.markForCheck();
        setTimeout(() => {
            BusyIndicator.SetStatusIdle("InfusionChart");
        }, 500);
    }    
    InvokeInfusionDetectChange(){
        setTimeout(() => {
            if(this.changeDetectionRef)
                this.changeDetectionRef.markForCheck();
        }, 0);
    }
    private IsValidDate(date: DateTime): boolean {
        let isvalid: boolean = false;  // 
        try {
            if (date != DateTime.MinValue || date != DateTime.MaxValue) {
                isvalid = true;
                return isvalid;
            }
            else return isvalid;
        }
        catch (ex: any) {
            return isvalid;
        }
    }

    private InfusionControl_RowLoaded(e: RowLoadedEventArgs): void {  //removed Telerik.Windows.Controls.
        try {
            if (this.ChartColumns != null) {
                if (this.ChartColumns.Count > 0) {
                    //   let t: Type = typeof(iGridViewHeaderRow);
                    if (typeof e.Row != typeof (iGridViewHeaderRow)) {
                        if (this.ChartRows[this.RowCount].DrugItem == null) {
                            return
                        }
                        if (this.ChartRows[this.RowCount].RowBackground.color.color != Colors.Transparent.color) {
                            this.InfusionControl.SetRowStyle(e, this.ChartRows[this.RowCount].RowBackground.color.color, 'Background', true)

                        } else {
                            this.ChartRows[this.RowCount].RowBackground = new SolidColorBrush(Color.FromArgb(1, 255, 255, 255))
                            this.InfusionControl.SetRowStyle(e, this.ChartRows[this.RowCount].RowBackground.color.color, 'Background', true)
                        }

                        if (this.ChartRows[this.RowCount].SequentialStart) {
                            let property = 'PART_ROWBORDETOP';
                            let rowBorder = {
                                Visibility : Visibility.Visible,
                                BorderBrush: new SolidColorBrush(Color.FromArgb(255, 0, 12, 254)),
                                BorderThickness: new Thickness(2, 0, 0, 0)
                            }
                            this.InfusionControl.SetRowStyle(e, rowBorder, property, true)
                           // this.InfusionControl.styles.push({ index: e.index, class: 'PART_RowBordeTOP_Blue' });
                        }

                        if (this.ChartRows[this.RowCount].SequentialEnd) {
                            let property = 'PART_ROWBORDERBOTTOM';
                            let rowBorder = {
                            BorderBrush: new SolidColorBrush(Color.FromArgb(255, 0, 12, 254)),
                            BorderThickness: new Thickness(0, 2, 0, 0)
                            }
                            this.InfusionControl.SetRowStyle(e, rowBorder, property,true);
                        }
                        // setTimeout(() => {
                            this.Row_SizeChanged(e.Row, null);
                       // }, 0);
                        if (this.rowrefresh) {
                                this.RowCount = 0;
                                return;
                            } else
                                this.RowCount += 1;
                    }
                    if (this.RowCount == this.ChartRows.Count) {
                        this.RowCount = 0;
                    }
                }
            }
            if(this.changeDetectionRef)
                this.changeDetectionRef.detectChanges();
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }

    }

     
    checkRowload = { content: {}, context: {} };
  
    objDictrowCnt: Dictionary<string, any> = new Dictionary<string, number>();
   
    Row_SizeChanged(sender: Object, e: SizeChangedEventArgs): void {
        try {
            let row: GridViewRow = ObjectHelper.CreateType<GridViewRow>(sender, GridViewRow);
            // revisit if (row.DataContext != null) {
            if (row.DataContext != null) {
                let nrowcount: number = (<InfusionChartRow>(row.DataContext)).RowIndex;
                let desiredHeight = row.Cells[0]?.DesiredSize?.Height;
                if (desiredHeight) {
                        this.heightDictionary.Add(this.ChartRows[nrowcount].Key, desiredHeight);
                }
              
                let rowkey: string = "Row" + nrowcount.ToString();
                if (!this.objDictrowCnt.ContainsValue(nrowcount)) {
                    this.objDictrowCnt.Add(rowkey, nrowcount);
                    for (let i: number = 0; i < this.ChartRows[nrowcount].InfusionChartCells.Count; i++) {
                       this.ChartRows[nrowcount].InfusionChartCells[i].cnvHeight = this.heightDictionary[this.ChartRows[nrowcount].Key];//this.heightDictionary[this.ChartRows[nrowcount].Key]
                        let oChartSlotType: InfusionChartCell = this.ChartRows[nrowcount].InfusionChartCells[i];
                        oChartSlotType.CreateProgressIconCollectionForCell(oChartSlotType);
                        let colIndex: number = this.ChartRows[nrowcount].InfusionChartCells[i].ColIndex;
                        let oChartCol: InfusionChartColumn = this.ChartColumns.Where(obj => obj.Index == colIndex).First();
                        oChartSlotType.DisplayTimeLine = oChartCol.IsCurrentTime;
                        oChartSlotType.cnvWidth = this.oChartColumns[colIndex].Width;
                        oChartSlotType.StartRange = this.oChartColumns[colIndex].StartRange;
                        oChartSlotType.EndRange = this.oChartColumns[colIndex].EndRange;
                        oChartSlotType.CurrentDateTime = this.CurrentDateTime;
                        oChartSlotType.CInterval = this.ChartColumns[colIndex].CInterval;
                        oChartSlotType.HighlightReviewSlot = this.ChartRows[nrowcount].InfusionChartCells[i].HighlightReviewSlot;
                        let objTagcon: InfusionTagObject = new InfusionTagObject();
                        objTagcon.oDrugItem = this.ChartRows[nrowcount].DrugItem;
                        objTagcon.oChartColumn = oChartCol;
                        objTagcon.oChartCell = this.ChartRows[nrowcount].InfusionChartCells[i];
                        objTagcon.oInfusionChartRow = this.ChartRows[nrowcount];
                        let Chartdetails: FrameworkElement = this.GetTemplate("cellitem", oChartSlotType);
                        objTagcon.oChartCell.HighlightReviewSlot = this.ChartRows[nrowcount].InfusionChartCells[i].HighlightReviewSlot;
                        Chartdetails.Tag = objTagcon;
                        let refreshKey = nrowcount+"-"+colIndex; 
                        if (this.rowrefresh && this.chartdetailsCellList.Count() > 0) {
                            if(this.chartdetailsCellList.ContainsKey(refreshKey)){
                               this.chartdetailsCellList[refreshKey] = Chartdetails;
                            }
                          //  console.log('refresh.chartdetailsCellList', this.chartdetailsCellList);
                          //  console.log('refresh.PRN.chartdetailsCellList',   this.chartdetailsCellList[refreshKey]);
                        }
                        else {
                            this.chartdetailsCellList.Add(refreshKey, Chartdetails);
                         //   console.log('refresh.normal.chartdetailsCellList', this.chartdetailsCellList);
                        }
                       row.Cells[colIndex].iStyle = !oChartSlotType.HighlightReviewSlot?{height:this.heightDictionary[this.ChartRows[nrowcount].Key]+'px'}:'';
                        row.Cells[colIndex].Content = (Chartdetails as any as DataTemplate).Content;
                        (Chartdetails as any as DataTemplate).Child.ChildAsTempRef = this.cellitem;
                        if (this.ChartRows[nrowcount].InfusionChartCells[i].DisplayTimeLine) {
                            if ((<SolidColorBrush>this.ChartRows[nrowcount].InfusionChartCells[i].ChartBackground).color.Equals(Colors.Transparent)) {
                                row.Cells[colIndex].Background = new SolidColorBrush(Color.FromArgb(255, 225, 225, 255));
                            }
                            else {
                                row.Cells[colIndex].Background = this.ChartRows[nrowcount].InfusionChartCells[i].ChartBackground;
                            }
                        }
                        else {
                            if ((<SolidColorBrush>this.ChartRows[nrowcount].InfusionChartCells[i].ChartBackground).color.Equals(Colors.Transparent)) {
                                row.Cells[colIndex].Background = 'transparent';
                            }
                            else {
                                row.Cells[colIndex].Background = this.ChartRows[nrowcount].InfusionChartCells[i].ChartBackground;
                            }
                        }
                        if (objTagcon.oChartCell.HighlightReviewSlot) {
                            row.Cells[colIndex].BorderBrush = new SolidColorBrush(Colors.Red);
                            row.Cells[colIndex].BorderThickness = new Thickness(2);
                        }
                        else{
                            row.Cells[colIndex].BorderBrush = new SolidColorBrush(Colors.Transparent);
                            row.Cells[colIndex].BorderThickness = new Thickness(0);
                        }
                        if(i == 11){
                            oChartSlotType.LastColum = true;
                        }
                       
                    }
                 this.InfusionControl.UpdateDataTemplateHeight(row.Cells);
                }
                if (this.InfusionControl.Columns.Count > 0) {
                    this.InfusionControl.Columns[0].Width = new GridViewLength(1, GridViewLengthUnitType.Star);
                }
            }
            if(this.changeDetectionRef)
                this.changeDetectionRef.markForCheck();
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }
    }
   
    public RowRefresh(updateObject: InfusionTagObject): void {
        try {
            this.selRowIndx = updateObject.oInfusionChartRow.RowIndex;
            //#region rowrefresh
            if (updateObject.oInfusionChartRow != null) {
                this.rowrefresh = true;
                // this.assignContent(this.selRowIndx, updateObject.oInfusionChartRow)
                // uncomment
                let context: { index: any, dataItem: any } = { index: 0, dataItem: {} };
                context.index = this.selRowIndx;
                context.dataItem = updateObject.oInfusionChartRow;
                this.checkRowload.context = context;
                this.ChartRows.RemoveAt(this.selRowIndx);
                this.ChartRows.Insert(this.selRowIndx,updateObject.oInfusionChartRow);
              // this.ChartRows[this.selRowIndx].InfusionChartCells = new ObservableCollection<InfusionChartCell>(updateObject.oInfusionChartRow.InfusionChartCells);
                let rowkey: string = "Row" + this.selRowIndx.ToString();
                this.objDictrowCnt.Remove(rowkey);
                // revisit
                // this.InfusionControl.Rows[this.selRowIndx].Cells[1].dataItem = updateObject.oInfusionChartRow;
                let rowEventArgs = this.InfusionControl.GetRowEventArgs(this.dataTemplates, context, false, true);
                rowEventArgs.Row.DataContext = this.ChartRows[this.selRowIndx];
                this.RowCount = this.selRowIndx;
              //  this.InfusionControl.RefreshDataTemplateHeight(this.dataTemplates);
                this.InfusionControl_RowLoaded(rowEventArgs);
                this.refreshRowBehaviorSubject.next(true);
            }
            setTimeout(() => {
                if(this.changeDetectionRef)
                    this.changeDetectionRef.markForCheck();
            }, 0);
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }

    }
    Drug_MouseLeftButtonDown(sender: Object, e: MouseButtonEventArgs): void {
        try {
            if (e.OriginalSource instanceof (Image)) {
                this.DrugItemFireImageClick(e.OriginalSource, e);
            }
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }
    }
    public DrugItemFireImageClick(sender: Object, e: MouseButtonEventArgs): void { //MouseButtonEventArgs
        try {
            let oImage: Image = <Image>sender;
            //  let objChartSlot: DrugItem = ObjectHelper.CreateType<DrugItem>(oImage.DataContext, DrugItem);
            let vChartCol: InfusionChartColumn = this.ChartColumns.Where(chartCols => chartCols.Index == 0).Select(chartCols => chartCols).First();
            let objTagCon: InfusionTagObject = new InfusionTagObject();
            objTagCon.oDrugItem = ObjectHelper.CreateType<DrugItem>(oImage.DataContext.DrugItem, DrugItem);
            objTagCon.oChartIcon = ObjectHelper.CreateType<ChartIcon>(oImage.Tag, ChartIcon);
            objTagCon.oChartCell = ObjectHelper.CreateType<InfusionChartCell>(oImage.DataContext.InfusionChartCells, InfusionChartCell);
            objTagCon.oChartColumn = vChartCol;
            objTagCon.oInfusionChartRow = ObjectHelper.CreateType<InfusionChartRow>(oImage.DataContext, InfusionChartRow);
            if (this.OnDrugHotSpotClick != null)
                this.OnDrugHotSpotClick(sender, objTagCon);
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }
    }
    objDrugDetails_SizeChanged(sender: Object, e: SizeChangedEventArgs): void {
        try {
            let IsChange: boolean = false;
            let fe: Border = ObjectHelper.CreateType<Border>(sender, Border);
            let pChartRow: InfusionChartRow = ObjectHelper.CreateType<InfusionChartRow>(fe.Tag, InfusionChartRow); //  declared property 'Tag' in border
            let Rowindex: number = pChartRow.RowIndex;
            if (pChartRow.InfusionChartCells != null && pChartRow.InfusionChartCells.Count > 0) {
                for (let indx: number = 0; indx < pChartRow.InfusionChartCells.Count; indx++) {
                    if (pChartRow.InfusionChartCells[indx] != null) {
                        if (pChartRow.InfusionChartCells[indx].cnvHeight >= fe.DesiredSize.Height) {
                            IsChange = false;
                            break;
                        }
                        IsChange = true;
                        break;
                    }
                }
            }
            if (IsChange) {
                for (let chartIndx: number = 0; chartIndx < pChartRow.InfusionChartCells.Count; chartIndx++) {
                    if (pChartRow.InfusionChartCells[chartIndx] != null) {
                        pChartRow.InfusionChartCells[chartIndx].cnvHeight = fe.DesiredSize.Height;
                    }
                }
                if (this.ChartRows != null) {
                    for (let j: number = 0; j < this.ChartRows[Rowindex].InfusionChartCells.Count; j++) {
                        let Chartdetails: FrameworkElement = this.GetTemplate("cellitem");
                        let oChartSlotType: InfusionChartCell = this.ChartRows[Rowindex].InfusionChartCells[j];
                        oChartSlotType.CreateProgressIconCollectionForCell(oChartSlotType);
                        let colIndex: number = this.ChartRows[Rowindex].InfusionChartCells[j].ColIndex;
                        let oChartCol: InfusionChartColumn = this.ChartColumns.Where(obj => obj.Index == colIndex).First();
                        oChartSlotType.DisplayTimeLine = oChartCol.IsCurrentTime;
                        oChartSlotType.cnvWidth = this.oChartColumns[colIndex].Width;
                        oChartSlotType.StartRange = this.oChartColumns[colIndex].StartRange;
                        oChartSlotType.EndRange = this.oChartColumns[colIndex].EndRange;
                        oChartSlotType.CurrentDateTime = this.CurrentDateTime;
                        oChartSlotType.CInterval = this.ChartColumns[colIndex].CInterval;
                        oChartSlotType.HighlightReviewSlot = this.ChartRows[Rowindex].InfusionChartCells[j].HighlightReviewSlot;
                        //  Chartdetails.MouseLeftButtonDown =(s,e)=>{this.Chart_MouseLeftButtonDown(s,e)};
                        Chartdetails.MouseLeftButtonDown = (s, e) => { this.Chart_MouseLeftButtonDown(s, e) };
                        let objTagcon: InfusionTagObject = new InfusionTagObject();
                        objTagcon.oDrugItem = this.ChartRows[Rowindex].DrugItem;
                        objTagcon.oChartColumn = oChartCol;
                        objTagcon.oChartCell = this.ChartRows[Rowindex].InfusionChartCells[j];
                        objTagcon.oChartCell.HighlightReviewSlot = this.ChartRows[Rowindex].InfusionChartCells[j].HighlightReviewSlot;
                        objTagcon.oInfusionChartRow = this.ChartRows[Rowindex];
                        Chartdetails.Tag = objTagcon;
                        Chartdetails.DataContext = oChartSlotType;
                        this.InfusionControl.Rows[Rowindex + 1].Cells[colIndex].Content = null;
                        this.InfusionControl.Rows[Rowindex + 1].Cells[colIndex].Content = Chartdetails;
                        this.InfusionControl.Rows[Rowindex + 1].Cells[colIndex].Background = this.ChartRows[Rowindex].InfusionChartCells[j].ChartBackground;
                        if (objTagcon.oChartCell.HighlightReviewSlot) {
                            this.InfusionControl.Rows[Rowindex + 1].Cells[colIndex].BorderBrush = new SolidColorBrush(Colors.Red);
                            this.InfusionControl.Rows[Rowindex + 1].Cells[colIndex].BorderThickness = new Thickness(2);
                        }
                    }
                }
                if (this.InfusionControl.Columns.Count > 0) {
                    //  this.UpdateLayout();
                    //
                    //  this.InfusionControl.Columns[0].Width = new GridViewLength(1, GridViewLengthUnitType.Star);
                    //   this.InfusionControl.UpdateLayout();
                    this.grdHeader.ColumnDefinitions[0].Width = new GridLength(this.InfusionControl.Columns[0].ActualWidth + 2);
                }
            }
        }
        catch (er) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(er);
        }

    }
    private CheckCurrentDataTime(oChartclms: InfusionChartColumn): boolean {
        if (String.Compare(this.StartDate.ToString("MM/dd/yyyy"), this.CurrentDateTime.ToString("MM/dd/yyyy")) == 0) {
            if (oChartclms.StartRange <= this.CurrentDateTime.Hour && this.CurrentDateTime.Hour <= oChartclms.EndRange)
                this.IsCurrentTime = true;
            else this.IsCurrentTime = false;
        }
        return this.IsCurrentTime;
    }
    cellborder_SizeChanged(sender: Object, e: SizeChangedEventArgs): void {  // created stub 'SizeChangedEventArgs' in FrameworkElement.ts 
        let fe: Border = ObjectHelper.CreateType<Border>(sender, Border);
        let ia: number = fe.DesiredSize.Height; // declare property 'DesiredSize' in border
    }

    oCommonBorder: Border;
    Chart_MouseLeftButtonDown(sender: Object, e: MouseButtonEventArgs): void {
        try {
            this.ChartClick(sender, e);
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }

    }
    public ChartClick(sender: Object, e: MouseButtonEventArgs): void {
        let oBorder: Border = <Border>sender;
        let objTagCon: InfusionTagObject = ObjectHelper.CreateType<InfusionTagObject>(oBorder.Tag, InfusionTagObject); // declare one 'Tag' property in border
        if (this.OnChartHotSpotClick) {
            if (objTagCon.oChartCell.EnableCellClick){
                this.OnChartHotSpotClick(sender, objTagCon);
            }
        }
    }

    public RefreshCell(updateObject: InfusionTagObject): void {
        try {
            let selRowIndx: number = updateObject.oInfusionChartRow.RowIndex;
            let selColIndx: number = updateObject.oChartColumn.Index;
            let objChartCell1: InfusionChartCell = this.ChartRows[selRowIndx].InfusionChartCells.Where(oC => oC == updateObject.oChartCell).First();
            this.InfusionControl.Rows[selRowIndx + 1].Cells[selColIndx].Content = null;
            let objChartCell: InfusionChartCell = updateObject.oChartCell;
            if (objChartCell != null) {
                let Chartdetails: FrameworkElement = this.GetTemplate("cellitem");
                let oChartSlotType: InfusionChartCell = objChartCell;
                oChartSlotType.CreateProgressIconCollectionForCell(oChartSlotType);
                let objcell: InfusionCell = new InfusionCell(); // add the reference of 'InfusionCellComponent'
                oChartSlotType.DisplayTimeLine = updateObject.oChartColumn.IsCurrentTime;
                oChartSlotType.cnvHeight = objChartCell1.cnvHeight;
                oChartSlotType.cnvWidth = updateObject.oChartColumn.Width;
                oChartSlotType.StartRange = updateObject.oChartColumn.StartRange;
                oChartSlotType.EndRange = updateObject.oChartColumn.EndRange;
                oChartSlotType.CurrentDateTime = updateObject.oChartColumn.CurrentDateTime;
                oChartSlotType.CInterval = updateObject.oChartColumn.CInterval; // type need to be changed
                oChartSlotType.HighlightReviewSlot = objChartCell.HighlightReviewSlot;
                Chartdetails.MouseLeftButtonDown = (s, e) => { this.Chart_MouseLeftButtonDown(s, e) }; // need to revisit also created the property 'MouseLeftButtonDown' in  FrameworkElement
                let objTagcon: InfusionTagObject = new InfusionTagObject();
                objTagcon.oDrugItem = updateObject.oDrugItem;
                objTagcon.oChartColumn = updateObject.oChartColumn;
                objTagcon.oChartCell = objChartCell;
                objTagcon.oChartCell.HighlightReviewSlot = objChartCell.HighlightReviewSlot;
                objTagcon.oInfusionChartRow = updateObject.oInfusionChartRow;
                Chartdetails.Tag = objTagcon; // created the property 'Tag' in  FrameworkElement
                Chartdetails.DataContext = oChartSlotType;
                this.InfusionControl.Rows[selRowIndx + 1].Cells[selColIndx].Content = Chartdetails;
                //this.InfusionControl.Rows[selRowIndx + 1].Cells[selColIndx].Background = objChartCell.ChartBackground; // revisit
                if (objTagcon.oChartCell.HighlightReviewSlot) {
                    this.InfusionControl.Rows[selRowIndx + 1].Cells[selColIndx].BorderBrush = new SolidColorBrush(Colors.Red);
                    this.InfusionControl.Rows[selRowIndx + 1].Cells[selColIndx].BorderThickness = new Thickness(2);
                }
            }
            if(this.changeDetectionRef)
                this.changeDetectionRef.markForCheck();
        }
        catch (err) {
            if (this.OnErrorLog != null)
                this.OnErrorLog(err);
        }

    }

    private GetTemplate<T = unknown>(TemplateKey: string, row?: InfusionChartCell): T {
        try {
            let oFrameworkElement;
            let cellitem: DataTemplate = this.cellItem(row);
            if (cellitem == null)
                return null;
            oFrameworkElement = ObjectHelper.CreateType<DataTemplate>(cellitem, DataTemplate);
            return oFrameworkElement;
        }
        catch (err) {
            console.log("GetTemplate", err);
            return null;
        }

    }

    NextDayView_Click(sender: Object, e: RoutedEventArgs): void {
     //   this.InfusionControl.RefreshDataTemplateHeight(this.dataTemplates);
        this.isLoaded = false;
        this.chartdetailsCellList.Clear();
               // this.EnablePreviousButton = true;
        // this.EnableNextButton = true;
        if (this.OnNextClick != null)
            this.OnNextClick(sender, e);
        this.ChartColumns = null;
        this.GenerateColumnList();
        this.txbTimeHeader.Text = this.Timeheader;
        this.PreviousDayView.IsEnabled = this.EnablePreviousButton;
        this.NextDayView.IsEnabled = this.EnableNextButton;
        if (this.InfusionControl.Columns.Count > 0) {

            // this.InfusionControl.Columns[0].Width = new GridViewLength(1, Telerik.Windows.Controls.GridViewLengthUnitType.Star);
            // Hari's team will take this up 'GridViewLength' should have a constaructor that take 2 arguments.

            // this.InfusionControl.UpdateLayout();
            //  this.grdHeader.ColumnDefinitions[0].Width = new GridLength(this.InfusionControl.Columns[0].ActualWidth + 2);
        }
        if (this.OnNextClickComplete != null)
            this.OnNextClickComplete(sender, e);
    }
    PreviousDayView_Click(sender: Object, e: RoutedEventArgs): void {
      //  this.InfusionControl.RefreshDataTemplateHeight(this.dataTemplates);
        this.isLoaded = false;
        this.chartdetailsCellList.Clear();
        //  this.EnablePreviousButton = true;
        //  this.EnableNextButton = true;
        if (this.OnPreviousClick != null)
            this.OnPreviousClick(sender, e);
        this.ChartColumns = null;
        this.GenerateColumnList();
        this.txbTimeHeader.Text = this.Timeheader;
        this.PreviousDayView.IsEnabled = this.EnablePreviousButton;
        this.NextDayView.IsEnabled = this.EnableNextButton;
        if (this.InfusionControl.Columns.Count > 0) {
            // this.UpdateLayout();

            //     this.InfusionControl.Columns[0].Width = new GridViewLength(1, Telerik.Windows.Controls.GridViewLengthUnitType.Star);  // Hari's team will take this up 'GridViewLength' should have a constaructor that take 2 arguments.

            //  this.InfusionControl.UpdateLayout();
            //  this.grdHeader.ColumnDefinitions[0].Width = new GridLength(this.InfusionControl.Columns[0].ActualWidth + 2);
        }
        if (this.OnPreviousClickComplete != null)
            this.OnPreviousClickComplete(sender, e);
    }
    private UserControl_Unloaded(sender: Object, e: RoutedEventArgs): void {
        // commented
        this.Loaded = null;//-= this.iInfusionChart_Loaded;
        // this.InfusionControl.RowLoaded = null;
        // this.InfusionControl.RowUnloaded = null ;// code commented
    }

    cellItem(datacontext?: InfusionChartCell) {
        let cellDataTemplate: DataTemplate = new DataTemplate();
        let border: Border = new Border();
        border.Name = 'cellborder';
        border.iStyle = this.Styles.BorderStyle1;
        border.DataContext = datacontext;
        cellDataTemplate.Content = border;
        return cellDataTemplate;
    }

    cursorImage(icon?: string){
        if(icon?.toLowerCase() == "assets/images/idiscontinuedrugnor16.png".toLowerCase() || icon?.toLowerCase() == "assets/images/Completed.png".toLowerCase())
            return "Auto"           
        else
            return "Hand";
        }
}